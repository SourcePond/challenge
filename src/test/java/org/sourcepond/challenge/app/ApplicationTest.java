/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.sourcepond.challenge.app;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.sourcepond.challenge.api.Classifier;
import org.sourcepond.challenge.testing.TestResourceBundle;

import java.io.PrintWriter;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.sourcepond.challenge.app.Application.SHUTDOWN_MESSAGE_KEY;

class ApplicationTest {
    private static final int EXPECTED_NUM_OF_RANGES = 1000;
    private static final String EXPECTED_SHUTDOWN_MESSAGE_FORMAT = "DDDD";
    private final ExecutorService executor = mock(ExecutorService.class);
    private final ClassifierFactory factory = mock(ClassifierFactory.class);
    private final Future<Classifier> classifierFuture = mock(Future.class);
    private final Classifier classifier = mock(Classifier.class);
    private final CLI cli = mock(CLI.class);
    private final ResultSinkFactory resultSinkFactory = mock(ResultSinkFactory.class);
    private final ResultSinkImpl sink = mock(ResultSinkImpl.class);
    private final PrintWriter console = mock(PrintWriter.class);
    private final Random random = mock(Random.class);
    private final Future future = mock(Future.class);
    private final TestResourceBundle bundle = mock(TestResourceBundle.class);
    private final Application application = new Application();

    @BeforeEach
    public void setup() throws Exception {
        when(cli.readNumOfRanges()).thenReturn(EXPECTED_NUM_OF_RANGES);
        when(executor.submit(sink)).thenReturn(future);
        when(classifierFuture.get()).thenReturn(classifier);
        when(factory.create(EXPECTED_NUM_OF_RANGES)).thenReturn(classifierFuture);
        when(resultSinkFactory.createResultSink(classifierFuture, random, console)).thenReturn(sink);
        when(bundle.handleGetObject(SHUTDOWN_MESSAGE_KEY)).thenReturn(EXPECTED_SHUTDOWN_MESSAGE_FORMAT);
        when(console.printf(EXPECTED_SHUTDOWN_MESSAGE_FORMAT)).thenReturn(console);

        application.setRandom(random);
        application.setExecutor(executor);
        application.setClassifierFactory(factory);
        application.setConsole(console);
        application.setCli(cli);
        application.setBundle(bundle);
        application.setResultSinkFactory(resultSinkFactory);
    }

    @Test
    public void startApp() {
        application.startApp();
        var order = inOrder(cli, future, classifier, executor);
        order.verify(executor).execute(sink);
        order.verify(cli).awaitUserExit();
        order.verify(cli).close();
        order.verify(executor).shutdownNow();
    }
}
